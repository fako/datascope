$window = $(window);
window.HIF = {
    resultSettings: { // should come from backend
        ratioWidth: 4,
        ratioHeight: 3,
        containerWidth: $window.width(),
        containerHeight: $window.height(),
        minimalWidth: 800,
        minimalHeight: 450,
        animationInterval: 10,
        animationDelay: 1000
    },
    waitingSettings: { // should come from backend
        retrySpeed: 1000,
        refreshSpeed: 250,
        refreshRate: 0.25,
        expectedDuration: 5000,
        maxProgress: 100
    }
};
// This file gets generated by grunt-ng-constant

angular.module('dsSettings', [])

.constant('DS', {translationEndpoint:'/api/v1/visual-translations-bric/service/',questionEndpoint:'/api/v1/question/',defaultMedium:'images'})

;
'use strict';

angular.module('dsMedia', []);
'use strict';

angular.module('dsMedia')
    .provider('videoService', {

        $get: ['_', '$sce', function(_, $sce) {

            var provider = this;

            function DSVideo(data) {

                this.vid = data.vid;
                this.thumbnail = data.thumbnail;
                this.autoplay = provider.autoplay || '0';
                this.viewPort = false;
                this.embedUrl = 'http://www.youtube.com/embed/'; // TODO: allow more sources

            }

            DSVideo.prototype.setViewport = function () {
                // TODO: remove global dependencies
                // TODO: duplicates code in ResultCtrl, move to separate service
                // TODO: inject instead of ask for dependencies
                // Some vars
                var rs = HIF.resultSettings;

                var windowWidth = angular.element(window).width();
                var viewWidth = Math.floor(windowWidth / 4); // TODO: remove hard code
                var viewHeight = viewWidth / rs.ratioWidth * rs.ratioHeight;
                viewHeight = Math.round(viewHeight);
                rs.imageWidth = viewWidth;
                rs.imageHeight = viewHeight;

                this.viewPort = {width: rs.imageWidth, height: rs.imageHeight};
            };

            DSVideo.prototype.setVideoSize = function () {

                if (!this.viewPort) {
                    this.setViewport();
                }
                this.width = this.viewPort.width;
                this.height = this.viewPort.width / 16 * 9;  // TODO: remove hard code

            };

            DSVideo.prototype.getSource = function (vids) {

                var vidsParam = '';
                _.forEach(vids, function (vid) {
                    vidsParam += vid + ',';
                });

                var params = '?' + 'autoplay=' + this.autoplay + '&controls=0&showinfo=0&playlist=' + vidsParam;
                return $sce.trustAsResourceUrl(this.embedUrl + this.vid + params);

            };

            DSVideo.prototype.style = function () {

                if (!this.width || !this.height) {
                    this.setVideoSize();
                }

                if (this.height < this.viewPort.height) {
                    return {
                        'margin-top': (this.viewPort.height - this.height) / 2 + 'px',
                        width: this.width,
                        height: this.height
                    };
                } else {
                    return { };
                }

            };

            return DSVideo;
        }]
    });

'use strict';

angular.module('globeScopeServices', [
    'dsMedia'
]);
'use strict';

angular.module('globeScopeServices')
    .provider('visualTranslationService', {

        $get: ['_', '$http', '$q', function (_, $http, $q) {

            var provider = this;

            return {

                // Setting constant values.
                // These might get overridden by app config
                url: provider.endpoint,
                medium: provider.medium || 'videos',

                // Variables here should be reset in reset()
                languages: {},
                randomLanguageCodes: [],
                words: {},
                compileCount: 0,
                query: '',
                deferred: false,
                promise: false,
                standby: true,
                error: false,

                reset: function () {

                    // Resetting the vars
                    this.languages = {};
                    this.randomLanguageCodes = [];
                    this.words = {};
                    this.compileCount = 0;
                    this.error = false;
                    this.query = '';
                    this.deferred = false;

                    // Prepare defer
                    this.deferred = $q.defer();
                    // When we're done we're on standby
                    var self = this;
                    this.deferred.promise['finally'](function () {
                        self.standby = true;
                    });

                },

                getResourceUrl: function () {
                    return this.url + this.query +'/?format=json';
                },

                get: function (query) {

                    // Make service available to callbacks through that var
                    var that = this;

                    if (!this.standby) {

                        if (query && query !== this.query) {

                            // The query is different than before
                            // So we reset and continue normal execution
                            this.reset();
                            this.query = query;
                            this.standby = false;
                        }

                    } else {

                        // We reset if service is standing by
                        // And claim it as
                        this.reset();
                        this.query = query;
                        this.standby = false;

                    }

                    $http({ method: 'GET', url: this.getResourceUrl() })
                        .success(function (data, status) {

                            if (status === 200) {
                                that.process(data.results);
                                that.deferred.resolve(status);
                            } else if (status === 202) {
                                that.deferred.notify(status); // 202, request accepted
                            } else if (status === 204) {
                                that.deferred.reject(status);
                            }

                        })
                        .error(function (data, status) {

                            that.error = data.detail;
                            that.deferred.reject(status);

                        });

                    return this.deferred.promise;
                },

                process: function (data) {

                    var languages = _.groupBy(data, 'language');
                    this.languages = _.mapValues(languages, this.processLanguage, this);
                    this.randomLanguageCodes = _.shuffle(_.keys(this.languages));

                    this.words = _.indexBy(data, 'word');
                    _.forEach(this.words, this.processWord, this);

                },

                processLanguage: function (translations) {

                    translations = _.pluck(translations, 'word');
                    translations = _.shuffle(translations);
                    translations.pad(12); // ensures length==12
                    translations = _.shuffle(translations);

                    return translations;

                },

                processWord: function (word) {

                    var wordExtension = {
                        img: 0,
                        vid: 0,
                        nextImage: function () {
                            if (this.img >= this.images.length) {
                                this.img = 0;
                            }
                            return this.images[this.img++];
                        },
                        nextVideo: function () {
                            if (this.vid >= this.videos.length) {
                                this.vid = 0;
                            }
                            return this.videos[this.vid++];
                        }
                    };

                    _.assign(word, wordExtension);
                    return word;

                }

            };

        }]
    })

    .directive('vtVisual', ['_', '$log', 'visualTranslationService', 'imageService', 'videoService',
        function(_, $log, $Translate, DSImage, DSVideo) {

            return {
                templateUrl: 'views/visual.html',
                scope: {
                    word: '@vtVisual',
                    medium: '@vtMedium',
                    flag: '@vtFlag'
                },
                replace: true,

                link: function($scope, el, attrs) {

                    function linkImageTranslation(word) {

                        if(_.isEmpty($Translate.words)) {
                            return;
                        }

                        var wordData = $Translate.words[word];
                        $scope.language = wordData.language;

                        var imageData = wordData.nextImage();
                        var image = new DSImage(imageData, $Translate.compileCount++);
                        $scope.image = image;
                        $scope.loaded = false;
                        $scope.source = image.thumbnailLink;

                        el.find('img').on('load', function () {

                            if(!$scope.loaded) {

                                $scope.loaded = true; // we're giving only one chance for bigger images
                                image.load().then(function() {

                                    // Successfully loaded big image!
                                    $scope.source = $scope.image.link;
                                    $scope.loaded = true;

                                });

                            }

                        });
                    }

                    function linkVideoTranslation(word) {

                        if(_.isEmpty($Translate.words)) {
                            return;
                        }

                        var wordData = $Translate.words[word];
                        $scope.language = wordData.language;

                        var videoData = wordData.nextVideo();
                        $scope.video = new DSVideo(videoData);
                        $scope.video.setVideoSize();
                        $scope.vids = _.pluck('vid', wordData.videos);

                    }

                    function linkFlag(word) {

                        if(_.isEmpty($Translate.words)) {
                            return;
                        }

                        var wordData = $Translate.words[word];
                        $scope.language = wordData.language;

                        $scope.flagStyle = ($scope.medium === 'videos') ? $scope.video.style() : {};


                    }

                    if($scope.medium === 'videos') {
                        attrs.$observe('vtVisual', linkVideoTranslation);
                    } else {
                        attrs.$observe('vtVisual', linkImageTranslation);
                    }

                    attrs.$observe('vtVisual', linkFlag);

                    $scope.$on('$destroy', function(){
                        delete $scope.image;
                        delete $scope.video;
                    });

                }

            };
        }
    ])

    .directive('dsFocusInput', function() {
        return {
            scope: { trigger: '@dsFocusInput' },
            link: function(scope, element) {
                scope.$watch('trigger', function(value) {
                    if(value === 'true') {
                        element[0].focus();
                    }
                });
            }
        };
    });
'use strict';

angular.module('globeScopeApp', [
        'ngSanitize',
        'ngCookies',
        'ui.router',
        'dsSettings',
        'globeScopeServices'

    ])

    // External library constants
    .constant('_', window._)

    // Plain javascript helper constants
    .constant('GET', function (sParam) {
        var sPageURL = window.location.search.substring(1), sURLVariables = sPageURL.split('&');
        for (var i = 0; i < sURLVariables.length; i++) {
            var sParameterName = sURLVariables[i].split('=');
            if (sParameterName[0] === sParam) { return sParameterName[1]; }
        }
    })

    .config(['DS', 'GET', '$stateProvider', '$urlRouterProvider', 'videoServiceProvider', 'visualTranslationServiceProvider',
        function(DS, GET, $stateProvider, $urlRouterProvider, videoServiceProvider, visualTranslationServiceProvider) {

            if(angular.element('html').hasClass('lte-ie9')) {
                return;
            }

            if(angular.element('html').hasClass('ie')) {
                HIF.animationDelay = 3000; // TODO: what is wrong with IE image loading?
            }

            videoServiceProvider.autoplay = GET('autoplay') || DS.autoplay || '0';

            visualTranslationServiceProvider.endpoint = DS.translationEndpoint;
            visualTranslationServiceProvider.medium = DS.defaultMedium;

            $stateProvider

                .state('main', {
                    url: '/',
                    onEnter: ['$rootScope',function($rootScope) {
                        $rootScope.loadClass = []; // TODO: refactor onEnter to stateChangeSuccess
                    }],
                    views: {
                        main: {
                            templateUrl: 'views/main.html',
                            controller: 'MainCtrl'
                        },
                        load: {
                            template: '',
                            controller: function() {}
                        }
                    }
                })

                .state('translate', {
                    url: '/result?q&lang',
                    onEnter: ['$rootScope',function($rootScope) {
                        $rootScope.loadClass = ['loading'];
                    }],
                    views: {
                        main: {
                            templateUrl: 'views/result.html',
                            controller: 'ResultCtrl'
                        },
                        load: {
                            templateUrl: 'views/waiting.html',
                            controller: 'WaitingCtrl'

                        }
                    }
                })

                .state('resize', {
                    params: {'referralState':null, 'referralQ':null},
                    onEnter: ['$rootScope',function($rootScope) {
                        $rootScope.loadClass = [];
                    }],
                    views: {
                        main: {
                            templateUrl: 'views/resize.html',
                            controller: 'ResizeCtrl'
                        },
                        load: {
                            template: '',
                            controller: function() {}
                        }
                    }
                })

                .state('error', {
                    onEnter: ['$rootScope',function($rootScope) {
                        $rootScope.loadClass = [];
                    }],
                    url: '/error',
                    views: {
                        main: {
                            templateUrl: 'views/error.html',
                            controller: 'ErrorCtrl'
                        },
                        load: {
                            template: '',
                            controller: function() {}
                        }
                    }

                })

                .state('no-results', {
                    onEnter: ['$rootScope',function($rootScope) {
                        $rootScope.loadClass = [];
                    }],
                    url: '/no-results',
                    views: {
                        main: {
                            templateUrl: 'views/no-results.html',
                            controller: 'NoResultsCtrl'
                        },
                        load: {
                            template: '',
                            controller: function() {}
                        }
                    }

                });

            $urlRouterProvider

                .otherwise('/');

        }
    ])

    .run(function() {
        // TODO: implement CSRF correctly
        //$http.defaults.headers.post['X-CSRFToken'] = $cookies.csrftoken;
        //$http.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';
    });


Array.prototype.pad = function(limit) {
	/**
	* Adds elements to the array until length of Array is equal to limit
	* It adds references from the beginning of the Array to pad the end.
	* It repeats the same elements when needed padding is longer than Array.length
	*/
	for(var i=0, length=this.length; this.length < limit; ++i) {
        this.push(this[i % length]);
	}

};

'use strict';

angular.module('globeScopeApp')
    .factory('imageService', ['$q', function($q) {

        function DSImage(data, propertySeed) {

            propertySeed = propertySeed || 0;

            this.propertySeed = propertySeed; // an integer used to determine CSS property
            this.width = data.width;
            this.height = data.height;
            this.link = data.url;
            this.thumbnailLink = data.thumbnail;
            this.deferred = $q.defer();

            this.yproperties = ['top', 'bottom'];
            this.xproperties = ['left', 'right'];
            this.noAnimationTreshold = 57;
            this.viewPort = false;

        }

        DSImage.prototype.setViewport = function() {
            // TODO: remove global dependencies
            // TODO: duplicates code in ResultCtrl, move to separate service
            // TODO: inject instead of ask for dependencies
            // Some vars
            var rs = HIF.resultSettings;

            var windowWidth = angular.element(window).width();
            var imageWidth = Math.floor(windowWidth / 4); // TODO: remove hard code
            var imageHeight = imageWidth / rs.ratioWidth * rs.ratioHeight;
            imageHeight = Math.round(imageHeight);
            rs.imageWidth = imageWidth;
            rs.imageHeight = imageHeight;

            this.viewPort = {width: rs.imageWidth, height: rs.imageHeight};
        };

        DSImage.prototype.isLandscapeOrientation = function () {
            return this.width > this.height;
        };

        DSImage.prototype.load = function() {

            if(!this.viewPort) {
                this.setViewport();
            }

            var self = this;

            var img = new Image();
            angular.element(img).load(function() {

                if (this.height < self.height || this.width < self.width) {
                    self.deferred.reject(self);
                    return;
                }

                self.width = this.width;
                self.height = this.height;
                self.deferred.resolve(self);


            })
            .error(function() {
                self.deferred.reject(self);
            })
            .prop('src', this.link);

            return this.deferred.promise;
        };

        DSImage.prototype.getOffsetProperty = function() {
            if(this.isLandscapeOrientation()) {
                return this.xproperties[this.propertySeed % 2];
            } else {
                return this.yproperties[this.propertySeed % 2];
            }
        };

        DSImage.prototype.getActualHeightWhenFullWidth = function(viewportDimensions) {

            // We calculate the actual image size based on the assumptions:
            // That width is as large as viewport width
            // And that we keep the ratio

            var widthRatio =  this.width / viewportDimensions.width;
            var actualImageHeight = this.height / widthRatio;
            return Math.round(actualImageHeight);

        };

        DSImage.prototype.getOverflowPercentage = function(viewportDimensions) {

            var overflowSize = this.getActualHeightWhenFullWidth(viewportDimensions) - viewportDimensions.height;
            return Math.ceil(overflowSize / viewportDimensions.height * 100);

		};

        DSImage.prototype.style = function() {

            if(!this.viewPort) {
                this.setViewport();
            }

            // Initial styling
            var animationInterval = HIF.resultSettings.animationInterval; // TODO: remove external dependency
            var transitionStyle = 'top ' + animationInterval +'s linear, bottom ' + animationInterval + 's linear';
            var styles = {
                width: '100%',
                '-webkit-transition': transitionStyle, /* For Safari 3.1 to 6.0 */
                transition: transitionStyle
            };

            // Styling based on overflow
            var overflowPercentage = this.getOverflowPercentage(this.viewPort);

            // TODO: make this hack properly into the class
            // TODO: have a look at images that would be too small with width 100%
            if(overflowPercentage <= 0) {
                styles.width = 'auto';
                styles.height = '100%';
                if(overflowPercentage < -1 * this.noAnimationTreshold) {
                    styles[this.getOffsetProperty()] = overflowPercentage / 2 + '%';
                }
                return styles;
            }
            if(this.isLandscapeOrientation() && styles.width === '100%') {
                return styles;
            }

            var hasSignificantOverflow = (overflowPercentage > this.noAnimationTreshold);
            if(hasSignificantOverflow) {
                styles[this.getOffsetProperty()] = -1 * overflowPercentage + '%';
            } else {
                styles[this.getOffsetProperty()] = -1 * (overflowPercentage / 2) + '%';
            }

            return styles;

        };

        DSImage.prototype.cssClass = function() {

            if(!this.viewPort) {
                this.setViewport();
            }

            var hasSignificantOverflow = (this.getOverflowPercentage(this.viewPort) > this.noAnimationTreshold);
            return (hasSignificantOverflow) ? this.getOffsetProperty() + '-overflow' : '';

        };

        return DSImage;
    }]);
'use strict';

angular.module('globeScopeApp')
    .factory('kioskService', function() {

        var kioskService = {

            containerWidth: 0,
            containerHeight: 0,

            setKioskSettings: function (kioskSettings) {

                // Gateway
                var ks = kioskSettings;
                if(this.containerWidth === ks.containerWidth && this.containerHeight === ks.containerHeight) {
                    return;
                }
                // Some code to monitor quality
                else if ((ks.containerWidth < ks.minimalWidth) || (ks.containerHeight < ks.minimalHeight)){
                    this.kioskStatus = 'no-fit';
                    return;
                } else {
                    this.containerWidth = ks.containerWidth;
                    this.containerHeight = ks.containerHeight;
                }

                // Default values
                this.kioskWidth = ks.containerWidth;
                this.kioskHeight = ks.containerHeight;
                this.kioskTop = 0;
                this.kioskLeft = 0;
                this.kioskStatus = 'fit';

                // Calculate ratios
                var idealRatio = ks.ratioWidth / ks.ratioHeight;
                var realRatio = ks.containerWidth / ks.containerHeight;

                // height of viewport to large
                // we need to restrict the height
                // we get whitespace above and below kiosk
                var whiteSpace, allowedHeight, allowedWidth;
                if(realRatio < idealRatio) {

                    allowedHeight = ks.containerWidth / ks.ratioWidth * ks.ratioHeight;
                    allowedHeight = Math.round(allowedHeight);
                    whiteSpace = Math.round((ks.containerHeight - allowedHeight) / 2);

                    this.kioskHeight = allowedHeight;
                    this.kioskTop = whiteSpace;
                    this.kioskStatus = 'mis-fit';

                // width of viewport to large
                // we need to restrict the width
                // we get whitespace left and right of kiosk
                } else if (realRatio > idealRatio) {

                    allowedWidth = ks.containerHeight / ks.ratioHeight * ks.ratioWidth;
                    allowedWidth = Math.round(allowedWidth);
                    whiteSpace = Math.round((ks.containerWidth - allowedWidth) / 2);

                    this.kioskWidth = allowedWidth;
                    this.kioskLeft = whiteSpace;
                    this.kioskStatus = 'mis-fit';

                }

            },

            style: function(kioskSettings) {

                this.setKioskSettings(kioskSettings);

                this.kioskStyle = {
                    width: this.kioskWidth,
                    height: this.kioskHeight,
                    top: this.kioskTop,
                    left: this.kioskLeft
                };

                return this.kioskStyle;
            },

            cssClass: function(kioskSettings) {

                this.setKioskSettings(kioskSettings);

                this.kioskClass = this.kioskStatus;

                return this.kioskClass;

            }
        };

        return kioskService;
    });
'use strict';

angular.module('globeScopeApp')

    .controller('MainCtrl', ['$scope', function ($scope) {

        $scope.placeholder = 'Enter one word and press the telescope';

    }]);

'use strict';

angular.module('globeScopeApp')

    .controller('SearchCtrl', ['$scope', '$state', function ($scope, $state) {

            $scope.translateToVisuals = function(query) {

                $state.go('translate',{q:query});

            };

        }

    ]);




'use strict';
/*global HIF, $ */

angular.module('globeScopeApp')

    .controller('ResultCtrl', ['$scope', '$rootScope', '$state', '$location', '$timeout', 'visualTranslationService',

        function ($scope, $rootScope, $state, $location, $timeout, $Translation) {
            
            var $window = $(window);
            var currentState = $state.current.name;
            var currentQ = $location.search().q;
            var currentLanguage = $location.search().lang;

            $scope.fullscreen = false;
            $scope.medium = $Translation.medium;

            // Ensure minimal width and height when loading ...
            if($window.width() < HIF.resultSettings.minimalWidth || $window.height() < HIF.resultSettings.minimalHeight) {
                $state.go('resize',{referralState:currentState,referralQ:currentQ}, {location: 'replace'});
                return;
            }

            var rs = HIF.resultSettings;
            var windowWidth = $window.width();
            var imageWidth = Math.floor(windowWidth / 4); // TODO: remove hard code
            var imageHeight = imageWidth / rs.ratioWidth * rs.ratioHeight;
            imageHeight = Math.round(imageHeight);
            rs.imageWidth = imageWidth;
            rs.imageHeight = imageHeight;

            $scope.languageContentStyle = {
                height: 3 * imageHeight // TODO: remove hard code
            };

            $scope.goTo = function(language) {
                $state.go('translate',{q:currentQ, lang:language}, {reload: true});
            };

            // TODO: move to kiosk service or resize service
            $window.resize(function() {
                $state.go('resize',{referralState:currentState,referralQ:currentQ}, {location: 'replace'});
            });

            var active = false;
            var animatePromise;
            function animate() {
                active = !active;
                $scope.animationClass = {active: active};
                animatePromise = $timeout(animate, HIF.resultSettings.animationInterval * 1000);
            }

            var resultsReceived = $scope.$on('results-received', function() {

                $scope.languages = $Translation.randomLanguageCodes;
                $scope.currentLanguage = currentLanguage || $scope.languages[0];
                $scope.results = $Translation.languages[$scope.currentLanguage];
                $scope.wordCount = 0;
                $timeout(animate, HIF.animationDelay);

            });

            $scope.$on('$destroy', function () {
                angular.element(window).unbind('resize'); // don't use $window it's slower
                resultsReceived(); // TODO: necessary or automatic?
                $timeout.cancel(animatePromise);
            });

        }
	]);

'use strict';

angular.module('globeScopeApp')

    .controller('ResizeCtrl', ['$scope', '$timeout', '$state', '$stateParams','kioskService',

		function ($scope, $timeout, $state, $stateParams, kiosk) {

			var kioskSettings = HIF.resultSettings;

			function relocate() {
				$scope.relocatePromise = $timeout(function() {
					$state.go($stateParams.referralState, {q:$stateParams.referralQ}, {location:'replace'});
				},1000);
			}
			relocate();

			$scope.$on(
				'resize',
				function(event) {

					$timeout.cancel($scope.relocatePromise);
					relocate();

					var $window = angular.element(window); // do not make global, this is faster
					event.currentScope.width = kioskSettings.containerWidth = $window.width();
					event.currentScope.height = kioskSettings.containerHeight = $window.height();
					event.currentScope.minimalWidth = kioskSettings.minimalWidth;
					event.currentScope.minimalHeight = kioskSettings.minimalHeight;

					// TODO: refactor the kiosk code
					event.currentScope.sizeClass = kiosk.cssClass(kioskSettings);
					if(kiosk.kioskStatus === 'no-fit') {
						$timeout.cancel($scope.relocatePromise);
					}

				}
			);

			// Initial values
			$scope.$emit('resize');

			// Act on browser resize
			angular.element(window).resize(function(){
				$scope.$apply(function() {
					$scope.$emit('resize');
				});
			});

			$scope.$on('$destroy', function () {
				angular.element(window).unbind('resize');
				$timeout.cancel($scope.relocatePromise);
			});

        }
	]);


'use strict';
/* globals alert */

angular.module('globeScopeApp')

    .controller('WaitingCtrl', ['_', '$scope', '$rootScope', '$state', '$stateParams', '$timeout', '$log', 'visualTranslationService',

		function (_, $scope, $rootScope, $state, $stateParams, $timeout, $log, $Translation) {

            if(!$stateParams.q) {
                $state.go('main');
            }

			// Preparation
			var ws = HIF.waitingSettings;
			$scope.maxProgress = ws.maxProgress;
			$scope.progress = 0;

			// Refresh logic
			var expectedAttempts = Math.ceil(ws.expectedDuration / ws.retrySpeed);
			var progressPerAttempt = Math.ceil(ws.maxProgress / expectedAttempts);
			var progressPerRefresh = Math.floor(progressPerAttempt * ws.refreshRate);
			var refreshPromise;
			function refresh() {
				$scope.progress += progressPerRefresh;
				if($scope.progress >= $scope.maxProgress) {
					$scope.progress = $scope.maxProgress - 3; // TODO: remove hard code

					return;
				}
				refreshPromise = $timeout(refresh, ws.refreshSpeed);
			}

			// Retrieve logic
			var retryPromise;
			function retrieve() {
				$Translation.get($stateParams.q).then(
                    function resolve() {
                        $rootScope.$broadcast('results-received');
                        $rootScope.loadClass = ['done'];
                    },
                    function reject(status) {
                        if(status === 400) {
                            if($Translation.error) {
                                $state.go('main',{}, {reload:true, location: 'replace'});
                                alert($Translation.error);
                            } else {
                                $log.warn('Received a 400 with unspecified error message.');
                                $state.go('error',{},{reload:true, location: 'replace'});
                            }
                        } else if(status === 204 || status === 404) {
                            $state.go('no-results',{},{reload:true, location: 'replace'});
                        } else {
                            $state.go('error',{},{reload:true, location: 'replace'});
                        }
                    },
                    function notify() {
                        if(_.isNull(retryPromise)) {
                            retryPromise = $timeout(retrieve, ws.retrySpeed);
                        }
                    }
			    );
                retryPromise = null;
			}

			// Fire off
			retrieve();
            refresh();

			// Deconstructor
			$scope.$on('$destroy', function () {
				$timeout.cancel(refreshPromise);
				$timeout.cancel(retryPromise);
			});

        }
	]);

'use strict';

angular.module('globeScopeApp')

    .controller('ErrorCtrl', function () { });




'use strict';
/* globals alert */

angular.module('globeScopeApp')

    .controller('QuestionCtrl', ['DS', '$scope', '$http', '$location', function (DS, $scope, $http, $location) {

        function addContext(form) {
            form.question = $scope.question;
            form.userAgent = navigator.userAgent;
            form.screen = $location.absUrl();
            form.referral = document.referrer;
            form.time = new Date().toISOString();
            return form;
        }

        $scope.send = function() {
            var data = addContext($scope.questionForm);
            $http.post(DS.questionEndpoint, data).then(
                function resolve() {
                    alert('Thank you for your feedback');
                }, function reject(){
                    alert('I\'m sorry, something went wrong with sending your feedback. Please try again.');
                }
            );
        };

    }]);




'use strict';

angular.module('globeScopeApp')

    .controller('NoResultsCtrl', ['$scope', 'visualTranslationService', function ($scope, $Translation) {

        $scope.query = $Translation.query;  // TODO: capitalize

    }]);
